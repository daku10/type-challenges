type CapitalizeChar<S extends string> = S extends 'a'
  ? 'A'
  : S extends 'b'
  ? 'B'
  : S extends 'c'
  ? 'C'
  : S extends 'd'
  ? 'D'
  : S extends 'e'
  ? 'E'
  : S extends 'f'
  ? 'F'
  : S extends 'g'
  ? 'G'
  : S extends 'h'
  ? 'H'
  : S extends 'g'
  ? 'G'
  : S extends 'h'
  ? 'H'
  : S extends 'i'
  ? 'I'
  : S extends 'j'
  ? 'J'
  : S extends 'k'
  ? 'K'
  : S extends 'l'
  ? 'L'
  : S extends 'm'
  ? 'M'
  : S extends 'n'
  ? 'N'
  : S extends 'o'
  ? 'O'
  : S extends 'p'
  ? 'P'
  : S extends 'q'
  ? 'Q'
  : S extends 'r'
  ? 'R'
  : S extends 's'
  ? 'S'
  : S extends 't'
  ? 'T'
  : S extends 'u'
  ? 'U'
  : S extends 'v'
  ? 'V'
  : S extends 'w'
  ? 'W'
  : S extends 'x'
  ? 'X'
  : S extends 'y'
  ? 'Y'
  : S extends 'z'
  ? 'Z'
  : S

type MyCapitalize<S extends string> = S extends `${infer T}${infer U}`
  ? `${CapitalizeChar<T>}${U}`
  : S

// another solution
// use map type
// type UpperCaseMap = {
//   a: 'A'
//   b: 'B'
//   c: 'C'
//   d: 'D'
//   e: 'E'
//   f: 'F'
//   g: 'G'
//   h: 'H'
//   i: 'I'
//   j: 'J'
//   k: 'K'
//   l: 'L'
//   m: 'M'
//   n: 'N'
//   o: 'O'
//   p: 'P'
//   q: 'Q'
//   r: 'R'
//   s: 'S'
//   t: 'T'
//   u: 'U'
//   v: 'V'
//   w: 'W'
//   x: 'X'
//   y: 'Y'
//   z: 'Z'
// }

// type MyCapitalize<S extends string> = S extends `${infer T}${infer U}`
//   ? T extends keyof UpperCaseMap
//     ? `${UpperCaseMap[T]}${U}`
//     : S
//   : S
